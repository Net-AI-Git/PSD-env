import matplotlib.pyplot as plt
import numpy as np
import os
from . import config


# ===================================================================
#
#           PSD Data Utilities
#
# This module provides utility functions for handling the PSD data,
# including reading from files, generating candidate points for the
# envelope, and plotting results.
#
# ===================================================================

def read_psd_data(filepath):
    """
    Reads PSD data from a two-column text file (frequency, amplitude).

    This function is designed to be robust, skipping empty lines and lines
    that start with '#' (comments).

    Args:
        filepath (str): The full path to the data file.

    Returns:
        tuple: A tuple containing two numpy arrays: (frequencies, psd_values).
               Returns (None, None) if the file cannot be found or read.
    """
    frequencies = []
    psd_values = []
    try:
        with open(filepath, 'r') as file:
            for line in file:
                line = line.strip()
                if line and not line.startswith('#'):
                    parts = line.split()
                    if len(parts) >= 2:
                        try:
                            freq = float(parts[0])
                            psd = float(parts[1])
                            frequencies.append(freq)
                            psd_values.append(psd)
                        except ValueError:
                            # Skip lines with non-numeric data
                            continue
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None, None
    return np.array(frequencies), np.array(psd_values)


def moving_window_maximum(psd_values, window_size=20):
    """
    Calculates the moving window maximum of a 1D array.

    For each point in the input array, it finds the maximum value within a
    symmetric window centered at that point. This is a key step in
    generating a coarse envelope.

    Args:
        psd_values (np.array): The input array of PSD amplitudes.
        window_size (int): The total size of the moving window.

    Returns:
        np.array: An array of the same shape as input, containing the
                  moving window maximum values.
    """
    result = np.zeros_like(psd_values)
    half_window = window_size // 2
    for i in range(len(psd_values)):
        start_idx = max(0, i - half_window)
        end_idx = min(len(psd_values), i + half_window + 1)
        result[i] = np.max(psd_values[start_idx:end_idx])
    return result


def simplify_envelope(frequencies, psd_values):
    """
    Reduces the number of points in an envelope by keeping only the "corner points".

    This function removes points that lie on a straight horizontal line,
    keeping only the points where the slope changes. This is useful for
    reducing the number of candidate points generated by the moving window maximum.

    Args:
        frequencies (np.array): The frequency values.
        psd_values (np.array): The amplitude values of the envelope.

    Returns:
        np.array: A 2D array of the simplified [frequency, psd_value] points.
    """
    if len(psd_values) < 3:
        return np.array([[f, p] for f, p in zip(frequencies, psd_values)])

    key_points = [[frequencies[0], psd_values[0]]]
    for i in range(1, len(psd_values) - 1):
        # A point is a "corner" if it's not equal to both its neighbors
        if psd_values[i] != psd_values[i - 1] or psd_values[i] != psd_values[i + 1]:
            key_points.append([frequencies[i], psd_values[i]])
    key_points.append([frequencies[-1], psd_values[-1]])

    return np.array(key_points)


def create_multi_scale_envelope(frequencies, psd_values, window_sizes):
    """
    Creates a rich set of candidate points for the genetic algorithm.

    It runs the `moving_window_maximum` function with multiple window sizes
    and combines the results. This multi-scale approach ensures that the pool
    of candidate points includes both fine-grained details and broader trends
    of the PSD signal, providing the GA with a good set of "building blocks".
    It can also optionally augment this set with "lifted" and original low-frequency points.

    Args:
        frequencies (np.array): The original frequency data.
        psd_values (np.array): The original PSD amplitude data.
        window_sizes (list[int]): A list of window sizes to use.

    Returns:
        np.array: A sorted, unique 2D array of all generated candidate points.
    """
    all_points = []
    print("\n--- Creating Multi-Scale Candidate Points ---")
    for window in window_sizes:
        moving_max = moving_window_maximum(psd_values, window_size=window)
        simplified = simplify_envelope(frequencies, moving_max)
        all_points.append(simplified)
        print(f"Window size {window}: Found {len(simplified)} points.")

    # Combine points from all scales, remove duplicates, and sort by frequency
    combined_points = np.vstack(all_points)
    unique_rows = np.unique(combined_points, axis=0)
    final_sorted_points = unique_rows[np.argsort(unique_rows[:, 0])]
    print(f"Total unique candidate points from all scales: {len(final_sorted_points)}")

    # Optional: Enrich the candidate space with original low-frequency points
    # This step is now performed BEFORE the lifting.
    if config.ENRICH_LOW_FREQUENCIES:
        print(f"--- Enriching with original points below {config.LOW_FREQUENCY_THRESHOLD} Hz ---")

        # Find all original PSD points below the threshold
        low_freq_mask = frequencies <= config.LOW_FREQUENCY_THRESHOLD
        low_freq_points = np.column_stack((frequencies[low_freq_mask], psd_values[low_freq_mask]))

        print(f"Found {len(low_freq_points)} original low-frequency points to add.")

        # Combine, remove duplicates, and re-sort to ensure a clean final set
        combined_final = np.vstack((final_sorted_points, low_freq_points))
        unique_final = np.unique(combined_final, axis=0)
        final_sorted_points = unique_final[np.argsort(unique_final[:, 0])]

        print(f"Total points after low-frequency enrichment: {len(final_sorted_points)}")

    # Optional: Augment the search space with "lifted" points.
    # This creates a second set of candidates by lifting them vertically.
    # A LIFT_FACTOR > 1 is required to enable this.
    if config.LIFT_FACTOR > 1:
        print(f"--- Augmenting candidate space with a lift factor of {config.LIFT_FACTOR} ---")

        # Create a deep copy of the current points to be lifted.
        lifted_points = final_sorted_points.copy()

        # --- BUG FIX: Perform lifting in log space for visual consistency ---
        # Previous method (lifted_points[:, 1] *= config.LIFT_FACTOR) was a linear multiplication
        # which did not translate to a constant visual shift on a log-scale plot.
        # The new method adds a constant in log-space, ensuring a uniform visual lift.

        # Add a small epsilon to prevent log(0) errors for PSD values of zero.
        epsilon = 1e-12
        log_values = np.log10(lifted_points[:, 1] + epsilon)
        log_lift = np.log10(config.LIFT_FACTOR)

        # Apply the lift in log space and convert back to linear scale.
        lifted_points[:, 1] = 10 ** (log_values + log_lift)

        # Combine the original points with the newly lifted points
        combined_final = np.vstack((final_sorted_points, lifted_points))
        unique_final = np.unique(combined_final, axis=0)
        final_sorted_points = unique_final[np.argsort(unique_final[:, 0])]

        print(f"Total points after augmentation: {len(final_sorted_points)}")

    return final_sorted_points


def plot_final_solution(original_freqs, original_psd, solution_points, final_area_ratio, input_filepath):
    """
    Renders and saves a dual view of the final optimized envelope solution.

    Args:
        original_freqs (np.array): The original frequency data.
        original_psd (np.array): The original PSD amplitude data.
        solution_points (np.array): The coordinates of the final envelope points.
        final_area_ratio (float): The calculated area ratio for the title.
        input_filepath (str): The path of the input file, used to name the output file.
    """
    # Set figsize to produce an output image of 1280x600 pixels (at 100 DPI)
    fig, axes = plt.subplots(2, 1, figsize=(12.8, 6.0))
    base_filename = os.path.basename(input_filepath)
    title_prefix = os.path.splitext(base_filename)[0]

    for ax, x_scale in zip(axes, ["log", "linear"]):
        ax.plot(original_freqs, original_psd, 'b-', label='Original PSD', linewidth=1.5, alpha=0.7)
        ax.plot(solution_points[:, 0], solution_points[:, 1], 'r-',
                label=f'Optimized Envelope ({len(solution_points)} points)', linewidth=2)
        ax.scatter(solution_points[:, 0], solution_points[:, 1], c='red', s=20, zorder=5)

        ax.set_xscale(x_scale)
        ax.set_yscale('log')
        ax.set_title(
            f'GA Result for {title_prefix} ({x_scale.capitalize()} X-axis) | Area Ratio: {final_area_ratio:.4f}, Points: {len(solution_points)}')
        ax.set_xlabel('Frequency [Hz]')
        ax.set_ylabel('PSD [gÂ²/Hz]')
        ax.grid(True, which="both", ls="--", alpha=0.5)
        ax.legend()

    # Manually set subplot parameters for consistent layout
    plt.subplots_adjust(left=0.065, bottom=0.083, right=0.997, top=0.944, wspace=0.2, hspace=0.332)

    # --- Save the figure instead of showing it ---
    # Create the output directory if it doesn't exist
    if not os.path.exists(config.OUTPUT_DIR):
        os.makedirs(config.OUTPUT_DIR)

    # Build the output path
    output_filename = f"{title_prefix}.png"
    output_path = os.path.join(config.OUTPUT_DIR, output_filename)

    # Save the figure
    plt.savefig(output_path)
    print(f"Result image saved to: {output_path}")

    # Close the plot to free up memory
    plt.close()



